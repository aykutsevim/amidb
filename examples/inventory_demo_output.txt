
*****************************************************
*     AmiDB Comprehensive Example Program           *
*     Demonstrating ALL Database Capabilities       *
*****************************************************

Platform: AmigaOS 3.1 / 68000 CPU
Constraints: 2MB RAM, 4KB Stack


=====================================================
PART A: DIRECT C API
=====================================================

===============================================
Example 1: B+Tree Basics
===============================================

1. Creating database 'RAM:inventory_direct.db'...
[DEBUG] pager_open: path=RAM:inventory_direct.db, read_only=0
[DEBUG] Allocating pager struct (92 bytes)...
[DEBUG] pager=0x400bd378
[DEBUG] Allocating file_path (24 bytes)...
[DEBUG] file_path=0x400a7b60
[DEBUG] Allocating page_buf (4096 bytes)...
[DEBUG] page_buf=0x410da060
[DEBUG] Entering new file branch
[DEBUG] Allocating bitmap (512 bytes)...
[DEBUG] bitmap=0x40dd6ad0
[DEBUG] Writing header page...
[DEBUG] file_write returned 4096 (expected 4096)
[DEBUG] Calling file_sync...
   Database created (page size: 4096 bytes)

2. Creating page cache (64 pages = 256 KB)...

3. Creating B+Tree index...
   B+Tree created (root page: 1, order: 64)

--- Inserting Products ---
   Product 1001: Amiga 500    -> price 299
   Product 1002: Amiga 1200   -> price 499
   Product 1003: Amiga 4000   -> price 1299
   Product 1004: Mouse        -> price 25
   Product 1005: Joystick     -> price 15

--- Searching ---
   Found Product 1003: price = 1299
   Product 9999: NOT FOUND (expected)

--- Updating ---
   Updating Product 1001: 299 -> 349
   Product 1001 now: 349

--- Deleting ---
   Deleting Product 1005...
   Product 1005 deleted.

--- Listing All Products (Cursor) ---
   Product ID Price
-----------------------------------------------
   1001       349
   1002       499
   1003       1299
   1004       25

--- B+Tree Statistics ---
   Entries: 4
   Height:  1
   Nodes:   1

[OK] Example 1 completed.

===============================================
Example 2: Row Serialization
===============================================

1. Creating a product row with multiple columns...
   Columns set: id, name, price, category, stock

--- Serializing Row ---
   Serialized to 49 bytes
   Format: length-prefixed, little-endian

--- Deserializing Row ---
   Deserialized 49 bytes
   Column count: 5

--- Reading Deserialized Values ---
   Column 0 (id):       1001
   Column 1 (name):     Amiga 500 Plus
   Column 2 (price):    349
   Column 3 (category): Computer
   Column 4 (stock):    5

--- Supported Data Types ---
   INTEGER: 32-bit signed (-2147483648 to 2147483647)
   TEXT:    Variable-length, length-prefixed
   BLOB:    Binary data, length-prefixed
   NULL:    Missing/unknown value

[OK] Example 2 completed.

===============================================
Example 3: ACID Transactions
===============================================

1. Opening database...
[DEBUG] pager_open: path=RAM:inventory_direct.db, read_only=0
[DEBUG] Allocating pager struct (92 bytes)...
[DEBUG] pager=0x400bd378
[DEBUG] Allocating file_path (24 bytes)...
[DEBUG] file_path=0x400a7b60
[DEBUG] Allocating page_buf (4096 bytes)...
[DEBUG] page_buf=0x410da060

2. Initializing transaction system...
   Write-Ahead Log created
   Transaction context created

--- Transaction 1: Commit ---
   Beginning transaction...
   Transaction ID: 1
   Adding Product 2001 (price: 599)
   Adding Product 2002 (price: 799)
   Committing transaction...
   Transaction COMMITTED - changes are durable!
   Verified: Product 2001 = 599

--- Transaction 2: Abort (Rollback) ---
   Beginning transaction...
   Transaction ID: 2
   Attempting bad changes:
   - Product 2001: 599 -> 9999
   - Adding Product 6666
   ABORTING transaction (simulating error)...
   Transaction ABORTED - changes rolled back!
   Verified: Product 2001 = 599 (unchanged)
   Verified: Product 6666 NOT FOUND (rolled back)

--- ACID Guarantees ---
   Atomicity:   All changes commit or all rollback
   Consistency: Database always valid
   Isolation:   Uncommitted changes invisible
   Durability:  Committed changes survive crashes

[OK] Example 3 completed.

===============================================
Example 4: Crash Recovery
===============================================

--- Phase 1: Commit Data Then Crash ---

1. Opening database and committing critical data...
[DEBUG] pager_open: path=RAM:inventory_direct.db, read_only=0
[DEBUG] Allocating pager struct (92 bytes)...
[DEBUG] pager=0x400bd378
[DEBUG] Allocating file_path (24 bytes)...
[DEBUG] file_path=0x400a7b60
[DEBUG] Allocating page_buf (4096 bytes)...
[DEBUG] page_buf=0x410da060
   Adding HIGH VALUE Product 8001 (price: 5000)
   Transaction COMMITTED.

2. Starting new transaction (will NOT commit)...
   Adding INVALID Product 8888 (should be lost)

3. *** SIMULATING POWER FAILURE ***
   Closing database WITHOUT commit...

--- Phase 2: Recovery After Crash ---

4. Reopening database (recovery happens automatically)...
[DEBUG] pager_open: path=RAM:inventory_direct.db, read_only=0
[DEBUG] Allocating pager struct (92 bytes)...
[DEBUG] pager=0x400bd378
[DEBUG] Allocating file_path (24 bytes)...
[DEBUG] file_path=0x400a7b60
[DEBUG] Allocating page_buf (4096 bytes)...
[DEBUG] page_buf=0x410da060

5. Verifying data integrity:
   Product 8001: 5000 - SURVIVED (committed data)
   Product 8888: NOT FOUND - CORRECT (uncommitted data)

--- Recovery Summary ---
   Committed transactions:   RECOVERED
   Uncommitted transactions: DISCARDED
   Database integrity:       VERIFIED

[OK] Example 4 completed.

=====================================================
PART B: SQL INTERFACE
=====================================================

===============================================
SQL Interface Examples
===============================================

Initializing SQL engine...
[DEBUG] pager_open: path=RAM:inventory_sql.db, read_only=0
[DEBUG] Allocating pager struct (92 bytes)...
[DEBUG] pager=0x400bd568
[DEBUG] Allocating file_path (21 bytes)...
[DEBUG] file_path=0x400a7b60
[DEBUG] Allocating page_buf (4096 bytes)...
[DEBUG] page_buf=0x412a55f0
[DEBUG] Entering new file branch
[DEBUG] Allocating bitmap (512 bytes)...
[DEBUG] bitmap=0x40dd6ad0
[DEBUG] Writing header page...
[DEBUG] file_write returned 4096 (expected 4096)
[DEBUG] Calling file_sync...
Database 'RAM:inventory_sql.db' ready.

===============================================
Example 5: CREATE TABLE and INSERT
===============================================

--- CREATE TABLE products ---
   SQL: CREATE TABLE products (
          id INTEGER PRIMARY KEY,
          name TEXT,
          price INTEGER,
          category TEXT,
          stock INTEGER
        )
   Table 'products' created.

--- CREATE TABLE logs ---
   SQL: CREATE TABLE logs (message TEXT, level INTEGER)
   Table 'logs' created (implicit rowid).

--- INSERT INTO products ---
   Inserting 10 products...
   10 rows inserted.

--- INSERT INTO logs ---
   3 log entries inserted.

[OK] Example 5 completed.

===============================================
Example 6: SELECT Queries
===============================================

--- SELECT * FROM products ---
   1, 'Amiga 500', 299, 'Computer', 10
   2, 'Amiga 1200', 499, 'Computer', 5
   3, 'Amiga 4000', 1299, 'Computer', 2
   4, 'Amiga CD32', 399, 'Console', 8
   5, 'Tank Mouse', 35, 'Peripheral', 50
   6, 'Competition Pro', 25, 'Peripheral', 40
   7, 'Action Replay', 79, 'Accessory', 15
   8, 'External Floppy', 89, 'Peripheral', 20
   9, 'Kickstart 3.1', 49, 'Software', 100
   10, 'Workbench 3.1', 39, 'Software', 100
   (10 rows)

--- SELECT WHERE category = 'Computer' ---
   1, 'Amiga 500', 299, 'Computer', 10
   2, 'Amiga 1200', 499, 'Computer', 5
   3, 'Amiga 4000', 1299, 'Computer', 2
   (3 rows)

--- SELECT WHERE price > 100 ---
   1, 'Amiga 500', 299, 'Computer', 10
   2, 'Amiga 1200', 499, 'Computer', 5
   3, 'Amiga 4000', 1299, 'Computer', 2
   4, 'Amiga CD32', 399, 'Console', 8
   (4 rows)

--- SELECT WHERE price <= 50 ---
   5, 'Tank Mouse', 35, 'Peripheral', 50
   6, 'Competition Pro', 25, 'Peripheral', 40
   9, 'Kickstart 3.1', 49, 'Software', 100
   10, 'Workbench 3.1', 39, 'Software', 100
   (4 rows)

--- SELECT ORDER BY price ASC ---
   6, 'Competition Pro', 25, 'Peripheral', 40
   5, 'Tank Mouse', 35, 'Peripheral', 50
   10, 'Workbench 3.1', 39, 'Software', 100
   9, 'Kickstart 3.1', 49, 'Software', 100
   7, 'Action Replay', 79, 'Accessory', 15
   8, 'External Floppy', 89, 'Peripheral', 20
   1, 'Amiga 500', 299, 'Computer', 10
   4, 'Amiga CD32', 399, 'Console', 8
   2, 'Amiga 1200', 499, 'Computer', 5
   3, 'Amiga 4000', 1299, 'Computer', 2
   (10 rows)

--- SELECT ORDER BY price DESC ---
   3, 'Amiga 4000', 1299, 'Computer', 2
   2, 'Amiga 1200', 499, 'Computer', 5
   4, 'Amiga CD32', 399, 'Console', 8
   1, 'Amiga 500', 299, 'Computer', 10
   8, 'External Floppy', 89, 'Peripheral', 20
   7, 'Action Replay', 79, 'Accessory', 15
   9, 'Kickstart 3.1', 49, 'Software', 100
   10, 'Workbench 3.1', 39, 'Software', 100
   5, 'Tank Mouse', 35, 'Peripheral', 50
   6, 'Competition Pro', 25, 'Peripheral', 40
   (10 rows)

--- SELECT LIMIT 3 ---
   1, 'Amiga 500', 299, 'Computer', 10
   2, 'Amiga 1200', 499, 'Computer', 5
   3, 'Amiga 4000', 1299, 'Computer', 2
   (3 rows)

--- SELECT WHERE + ORDER BY + LIMIT ---
   SQL: SELECT * FROM products WHERE price > 50
        ORDER BY price DESC LIMIT 5
   3, 'Amiga 4000', 1299, 'Computer', 2
   2, 'Amiga 1200', 499, 'Computer', 5
   4, 'Amiga CD32', 399, 'Console', 8
   1, 'Amiga 500', 299, 'Computer', 10
   8, 'External Floppy', 89, 'Peripheral', 20
   (5 rows)

[OK] Example 6 completed.

===============================================
Example 7: UPDATE and DELETE
===============================================

--- Before UPDATE ---
   Product 1 (Amiga 500):
   1, 'Amiga 500', 299, 'Computer', 10
   (1 row)

--- UPDATE by PRIMARY KEY ---
   SQL: UPDATE products SET price = 349 WHERE id = 1
   Parse error: UPDATE not yet implemented
   After UPDATE:
   1, 'Amiga 500', 299, 'Computer', 10
   (1 row)

--- UPDATE multiple rows ---
   SQL: UPDATE products SET stock = 999 WHERE category = 'Software'
   Parse error: UPDATE not yet implemented
   Software products after UPDATE:
   9, 'Kickstart 3.1', 49, 'Software', 100
   10, 'Workbench 3.1', 39, 'Software', 100
   (2 rows)

--- DELETE by PRIMARY KEY ---
   Before: Product count =    10
   (1 row)
   SQL: DELETE FROM products WHERE id = 10
   Parse error: DELETE not yet implemented
   After: Product count =    10
   (1 row)

--- DELETE by condition ---
   SQL: DELETE FROM products WHERE price < 40
   Parse error: DELETE not yet implemented
   Remaining products:
   1, 'Amiga 500', 299, 'Computer', 10
   2, 'Amiga 1200', 499, 'Computer', 5
   3, 'Amiga 4000', 1299, 'Computer', 2
   4, 'Amiga CD32', 399, 'Console', 8
   5, 'Tank Mouse', 35, 'Peripheral', 50
   6, 'Competition Pro', 25, 'Peripheral', 40
   7, 'Action Replay', 79, 'Accessory', 15
   8, 'External Floppy', 89, 'Peripheral', 20
   9, 'Kickstart 3.1', 49, 'Software', 100
   10, 'Workbench 3.1', 39, 'Software', 100
   (10 rows)

[OK] Example 7 completed.

===============================================
Example 8: Aggregate Functions
===============================================

--- COUNT(*) ---
   SQL: SELECT COUNT(*) FROM products
   Total products:    10
   (1 row)

--- COUNT(*) with WHERE ---
   SQL: SELECT COUNT(*) FROM products WHERE price > 100
   Products over $100:    4
   (1 row)

--- SUM ---
   SQL: SELECT SUM(price) FROM products
   Total inventory value: $   2812
   (1 row)

--- SUM with WHERE ---
   SQL: SELECT SUM(price) FROM products WHERE category = 'Computer'
   Computer inventory value: $   2097
   (1 row)

--- AVG ---
   SQL: SELECT AVG(price) FROM products
   Average price: $   281
   (1 row)

--- MIN ---
   SQL: SELECT MIN(price) FROM products
   Cheapest product: $   25
   (1 row)

--- MAX ---
   SQL: SELECT MAX(price) FROM products
   Most expensive product: $   1299
   (1 row)

--- MAX with WHERE ---
   SQL: SELECT MAX(stock) FROM products WHERE category = 'Peripheral'
   Highest peripheral stock:    50
   (1 row)

[OK] Example 8 completed.

===============================================
Example 9: DROP TABLE
===============================================

--- Tables Before DROP ---
   Tables (2):
     - products
     - logs

--- DROP TABLE logs ---
   SQL: DROP TABLE logs
   Table 'logs' dropped.

--- Tables After DROP ---
   Tables (1):
     - products

--- DROP Non-Existent Table ---
   SQL: DROP TABLE nonexistent
   Error: Table 'nonexistent' does not exist
   (Error is expected)

--- Recreate logs with new schema ---
   SQL: CREATE TABLE logs (id INTEGER PRIMARY KEY, msg TEXT, severity INTEGER)
   New 'logs' table created.
   2 rows inserted into new schema.
   New table contents:
   1, 'System rebooted', 1
   2, 'Error detected', 3
   (2 rows)

[OK] Example 9 completed.

===============================================
Example 10: Complete Inventory Workflow
===============================================

=== DAILY INVENTORY REPORT ===

--- Inventory Summary ---
   Total Products:    10
   (1 row)
   Total Value: $   2812
   (1 row)
   Average Price: $   281
   (1 row)
   Price Range: $   25 - $1299

--- By Category ---
   Computers:    3
   (1 row)
   Peripherals:    3
   (1 row)
   Accessories:    1
   (1 row)

--- High-Value Items (> $200) ---
   3, 'Amiga 4000', 1299, 'Computer', 2
   2, 'Amiga 1200', 499, 'Computer', 5
   4, 'Amiga CD32', 399, 'Console', 8
   1, 'Amiga 500', 299, 'Computer', 10
   (4 rows)

--- Low Stock Alert (< 10 units) ---
   2, 'Amiga 1200', 499, 'Computer', 5
   3, 'Amiga 4000', 1299, 'Computer', 2
   4, 'Amiga CD32', 399, 'Console', 8
   (3 rows)

--- Recent System Logs ---
   2, 'Error detected', 3
   1, 'System rebooted', 1
   (2 rows)

--- Processing Sale: Amiga 1200 ---
   Before sale:
   2, 'Amiga 1200', 499, 'Computer', 5
   (1 row)
   Updating stock (5 -> 4)...
   Parse error: UPDATE not yet implemented
   After sale:
   2, 'Amiga 1200', 499, 'Computer', 5
   (1 row)

[OK] Example 10 completed.

===============================================
DEMONSTRATION COMPLETE
===============================================

All examples completed successfully!

Capabilities Demonstrated:
  DIRECT API:
    [x] Pager - Page-based file I/O
    [x] Cache - LRU page caching
    [x] B+Tree - Indexed storage (insert/search/delete/cursor)
    [x] Row - Multi-column serialization
    [x] WAL - Write-Ahead Logging
    [x] Transactions - ACID guarantees
    [x] Recovery - Crash recovery

  SQL INTERFACE:
    [x] CREATE TABLE - Schema definition
    [x] DROP TABLE - Schema removal
    [x] INSERT - Data insertion
    [x] SELECT - Queries with WHERE/ORDER BY/LIMIT
    [x] UPDATE - Data modification
    [x] DELETE - Data removal
    [x] COUNT(*) - Row counting
    [x] SUM() - Numeric summation
    [x] AVG() - Numeric averaging
    [x] MIN() - Minimum value
    [x] MAX() - Maximum value

AmiDB is ready for your Amiga applications!

