/*
 * executor.c - SQL executor implementation
 *
 * Week 4: CREATE TABLE execution only
 * Week 5: INSERT execution added
 */

#include "sql/executor.h"
#include "storage/row.h"
#include "storage/btree.h"
#include <string.h>
#include <stdio.h>
#include <stdlib.h>

/* Forward declarations */
static void set_error(struct sql_executor *exec, const char *message);

/* Helper structure for ORDER BY - holds row data for sorting */
struct row_buffer {
    int32_t sort_key_int;        /* Integer sort key */
    char sort_key_text[256];     /* Text sort key */
    uint8_t sort_key_type;       /* AMIDB_TYPE_* */
    struct amidb_row row;        /* Deserialized row */
};

/* Comparison function for qsort (ascending integer) */
static int compare_rows_int_asc(const void *a, const void *b) {
    const struct row_buffer *ra = (const struct row_buffer *)a;
    const struct row_buffer *rb = (const struct row_buffer *)b;
    if (ra->sort_key_int < rb->sort_key_int) return -1;
    if (ra->sort_key_int > rb->sort_key_int) return 1;
    return 0;
}

/* Comparison function for qsort (descending integer) */
static int compare_rows_int_desc(const void *a, const void *b) {
    return compare_rows_int_asc(b, a);
}

/* Comparison function for qsort (ascending text) */
static int compare_rows_text_asc(const void *a, const void *b) {
    const struct row_buffer *ra = (const struct row_buffer *)a;
    const struct row_buffer *rb = (const struct row_buffer *)b;
    return strcmp(ra->sort_key_text, rb->sort_key_text);
}

/* Comparison function for qsort (descending text) */
static int compare_rows_text_desc(const void *a, const void *b) {
    return compare_rows_text_asc(b, a);
}

/*
 * Initialize executor
 */
int executor_init(struct sql_executor *exec, struct amidb_pager *pager,
                  struct page_cache *cache, struct catalog *catalog) {
    exec->pager = pager;
    exec->cache = cache;
    exec->catalog = catalog;
    exec->txn = NULL;  /* Transaction support added in Week 5+ */
    exec->has_error = 0;
    exec->error_msg[0] = '\0';

    return 0;
}

/*
 * Close executor
 */
void executor_close(struct sql_executor *exec) {
    /* Nothing to clean up for now */
    (void)exec;
}

/*
 * Execute SQL statement
 */
int executor_execute(struct sql_executor *exec, const struct sql_statement *stmt) {
    /* Clear previous error */
    exec->has_error = 0;
    exec->error_msg[0] = '\0';

    /* Dispatch to appropriate handler */
    switch (stmt->type) {
        case STMT_CREATE_TABLE:
            return executor_create_table(exec, &stmt->stmt.create_table);

        case STMT_DROP_TABLE:
            return executor_drop_table(exec, &stmt->stmt.drop_table);

        case STMT_INSERT:
            return executor_insert(exec, &stmt->stmt.insert);

        case STMT_SELECT:
            return executor_select(exec, &stmt->stmt.select);

        case STMT_UPDATE:
            return executor_update(exec, &stmt->stmt.update);

        case STMT_DELETE:
            return executor_delete(exec, &stmt->stmt.delete);

        default:
            set_error(exec, "Unknown statement type");
            return -1;
    }
}

/*
 * Get last error message
 */
const char *executor_get_error(struct sql_executor *exec) {
    return exec->error_msg;
}

/*
 * Execute CREATE TABLE
 */
int executor_create_table(struct sql_executor *exec, const struct sql_create_table *create_stmt) {
    int rc;
    int i;
    int pk_count = 0;

    /* Validate table name */
    if (create_stmt->table_name[0] == '\0') {
        set_error(exec, "Table name cannot be empty");
        return -1;
    }

    /* Validate column count */
    if (create_stmt->column_count == 0) {
        set_error(exec, "Table must have at least one column");
        return -1;
    }

    if (create_stmt->column_count > 32) {
        set_error(exec, "Table cannot have more than 32 columns");
        return -1;
    }

    /* Validate columns */
    for (i = 0; i < create_stmt->column_count; i++) {
        /* Check column name */
        if (create_stmt->columns[i].name[0] == '\0') {
            set_error(exec, "Column name cannot be empty");
            return -1;
        }

        /* Check data type */
        if (create_stmt->columns[i].type != SQL_TYPE_INTEGER &&
            create_stmt->columns[i].type != SQL_TYPE_TEXT &&
            create_stmt->columns[i].type != SQL_TYPE_BLOB) {
            set_error(exec, "Invalid column data type");
            return -1;
        }

        /* Count PRIMARY KEYs */
        if (create_stmt->columns[i].is_primary_key) {
            pk_count++;
        }
    }

    /* Validate PRIMARY KEY constraint */
    if (pk_count > 1) {
        set_error(exec, "Table can have at most one PRIMARY KEY");
        return -1;
    }

    /* If PRIMARY KEY exists, it must be INTEGER type */
    if (pk_count == 1) {
        for (i = 0; i < create_stmt->column_count; i++) {
            if (create_stmt->columns[i].is_primary_key) {
                if (create_stmt->columns[i].type != SQL_TYPE_INTEGER) {
                    set_error(exec, "PRIMARY KEY must be INTEGER type");
                    return -1;
                }
                break;
            }
        }
    }

    /* Create table in catalog */
    rc = catalog_create_table(exec->catalog, create_stmt);
    if (rc != 0) {
        snprintf(exec->error_msg, sizeof(exec->error_msg),
                 "Table '%s' already exists", create_stmt->table_name);
        exec->has_error = 1;
        return -1;
    }

    return 0;
}

/*
 * Execute DROP TABLE (Week 4+: stub)
 */
int executor_drop_table(struct sql_executor *exec, const struct sql_drop_table *drop_stmt) {
    set_error(exec, "DROP TABLE not yet implemented");
    return -1;
}

/*
 * Execute INSERT (Week 5)
 */
int executor_insert(struct sql_executor *exec, const struct sql_insert *insert_stmt) {
    struct table_schema schema;
    struct amidb_row row;
    struct btree *table_tree;
    uint8_t row_buffer[4096];
    int32_t primary_key;
    uint32_t row_page;
    int rc;
    int row_size;
    uint32_t i;
    uint8_t *page_data;

    /* Retrieve table schema */
    rc = catalog_get_table(exec->catalog, insert_stmt->table_name, &schema);
    if (rc != 0) {
        snprintf(exec->error_msg, sizeof(exec->error_msg),
                 "Table '%s' does not exist", insert_stmt->table_name);
        exec->has_error = 1;
        return -1;
    }

    /* Validate value count matches column count */
    if (insert_stmt->value_count != schema.column_count) {
        snprintf(exec->error_msg, sizeof(exec->error_msg),
                 "Column count mismatch: expected %u, got %u",
                 schema.column_count, insert_stmt->value_count);
        exec->has_error = 1;
        return -1;
    }

    /* Build row from values */
    row_init(&row);

    for (i = 0; i < insert_stmt->value_count; i++) {
        const struct sql_value *val = &insert_stmt->values[i];
        const struct sql_column_def *col = &schema.columns[i];

        /* Set value based on type */
        switch (val->type) {
            case SQL_VALUE_INTEGER:
                if (col->type != SQL_TYPE_INTEGER) {
                    snprintf(exec->error_msg, sizeof(exec->error_msg),
                             "Type mismatch for column '%s': expected INTEGER", col->name);
                    exec->has_error = 1;
                    row_clear(&row);
                    return -1;
                }
                row_set_int(&row, i, val->int_value);
                break;

            case SQL_VALUE_TEXT:
                if (col->type != SQL_TYPE_TEXT) {
                    snprintf(exec->error_msg, sizeof(exec->error_msg),
                             "Type mismatch for column '%s': expected TEXT", col->name);
                    exec->has_error = 1;
                    row_clear(&row);
                    return -1;
                }
                row_set_text(&row, i, val->text_value, 0);
                break;

            case SQL_VALUE_NULL:
                row_set_null(&row, i);
                break;

            default:
                snprintf(exec->error_msg, sizeof(exec->error_msg),
                         "Unsupported value type for column '%s'", col->name);
                exec->has_error = 1;
                row_clear(&row);
                return -1;
        }
    }

    /* Determine PRIMARY KEY value */
    if (schema.primary_key_index >= 0) {
        /* Explicit PRIMARY KEY */
        const struct amidb_value *pk_val = row_get_value(&row, schema.primary_key_index);
        if (pk_val == NULL || pk_val->type != AMIDB_TYPE_INTEGER) {
            set_error(exec, "PRIMARY KEY must be INTEGER");
            row_clear(&row);
            return -1;
        }
        primary_key = pk_val->u.i;
    } else {
        /* Implicit rowid - use auto-increment */
        primary_key = (int32_t)schema.next_rowid;
    }

    /* Serialize row */
    row_size = row_serialize(&row, row_buffer, sizeof(row_buffer));
    if (row_size < 0) {
        set_error(exec, "Failed to serialize row");
        row_clear(&row);
        return -1;
    }

    /* Allocate page for row data */
    rc = pager_allocate_page(exec->pager, &row_page);
    if (rc != 0) {
        set_error(exec, "Failed to allocate page for row");
        row_clear(&row);
        return -1;
    }

    /* Write serialized row to page */
    rc = cache_get_page(exec->cache, row_page, &page_data);
    if (rc != 0) {
        set_error(exec, "Failed to get page for row");
        row_clear(&row);
        return -1;
    }

    memcpy(page_data, row_buffer, row_size);
    cache_mark_dirty(exec->cache, row_page);
    cache_unpin(exec->cache, row_page);

    /* Open table B+Tree */
    table_tree = btree_open(exec->pager, exec->cache, schema.btree_root);
    if (table_tree == NULL) {
        set_error(exec, "Failed to open table B+Tree");
        row_clear(&row);
        return -1;
    }

    /* Insert into B+Tree: primary_key â†’ row_page */
    rc = btree_insert(table_tree, primary_key, row_page);
    if (rc != 0) {
        snprintf(exec->error_msg, sizeof(exec->error_msg),
                 "Failed to insert row (duplicate PRIMARY KEY: %d)", primary_key);
        exec->has_error = 1;
        btree_close(table_tree);
        row_clear(&row);
        return -1;
    }

    btree_close(table_tree);

    /* If implicit rowid, update schema.next_rowid */
    if (schema.primary_key_index < 0) {
        schema.next_rowid++;
        schema.row_count++;
        rc = catalog_update_table(exec->catalog, &schema);
        if (rc != 0) {
            set_error(exec, "Failed to update table metadata");
            row_clear(&row);
            return -1;
        }
    } else {
        /* Explicit PRIMARY KEY - just update row count */
        schema.row_count++;
        catalog_update_table(exec->catalog, &schema);
    }

    row_clear(&row);
    return 0;
}

/*
 * Execute SELECT (Week 6)
 */
int executor_select(struct sql_executor *exec, const struct sql_select *select_stmt) {
    struct table_schema schema;
    struct btree *table_tree;
    struct btree_cursor cursor;
    struct amidb_row row;
    uint8_t *page_data;
    uint32_t row_page;
    int rc;
    int match_count = 0;
    int i;

    /* Retrieve table schema */
    rc = catalog_get_table(exec->catalog, select_stmt->table_name, &schema);
    if (rc != 0) {
        snprintf(exec->error_msg, sizeof(exec->error_msg),
                 "Table '%s' does not exist", select_stmt->table_name);
        exec->has_error = 1;
        return -1;
    }

    /* Open table B+Tree */
    table_tree = btree_open(exec->pager, exec->cache, schema.btree_root);
    if (table_tree == NULL) {
        set_error(exec, "Failed to open table B+Tree");
        return -1;
    }

    /* Print column headers */
    printf("\n");
    for (i = 0; i < schema.column_count; i++) {
        printf("%-20s", schema.columns[i].name);
    }
    printf("\n");
    for (i = 0; i < schema.column_count; i++) {
        printf("--------------------");
    }
    printf("\n");

    /* WHERE clause optimization: Direct search on PRIMARY KEY */
    if (select_stmt->where.has_condition) {
        /* Check if WHERE is on PRIMARY KEY column */
        int is_pk_where = 0;
        if (schema.primary_key_index >= 0) {
            if (strcmp(select_stmt->where.column_name,
                      schema.columns[schema.primary_key_index].name) == 0) {
                is_pk_where = 1;
            }
        } else {
            /* Implicit rowid - check for "rowid" column name */
            if (strcmp(select_stmt->where.column_name, "rowid") == 0) {
                is_pk_where = 1;
            }
        }

        if (is_pk_where && select_stmt->where.op == SQL_OP_EQ) {
            /* Fast path: Direct B+Tree search for PRIMARY KEY equality */
            if (select_stmt->where.value.type != SQL_VALUE_INTEGER) {
                set_error(exec, "WHERE on PRIMARY KEY requires INTEGER value");
                btree_close(table_tree);
                return -1;
            }

            rc = btree_search(table_tree, select_stmt->where.value.int_value, &row_page);
            if (rc == 0) {
                /* Row found - fetch and display */
                rc = cache_get_page(exec->cache, row_page, &page_data);
                if (rc == 0) {
                    row_init(&row);
                    row_deserialize(&row, page_data, 4096);

                    /* Print row */
                    for (i = 0; i < schema.column_count && i < row.column_count; i++) {
                        const struct amidb_value *val = row_get_value(&row, i);
                        if (val->type == AMIDB_TYPE_INTEGER) {
                            printf("%-20d", val->u.i);
                        } else if (val->type == AMIDB_TYPE_TEXT) {
                            printf("%-20.*s", (int)val->u.blob.size, (char*)val->u.blob.data);
                        } else if (val->type == AMIDB_TYPE_NULL) {
                            printf("%-20s", "NULL");
                        }
                    }
                    printf("\n");
                    match_count = 1;

                    row_clear(&row);
                    cache_unpin(exec->cache, row_page);
                }
            }

            printf("\n%d row(s) selected.\n", match_count);
            btree_close(table_tree);
            return 0;
        }
    }

    /* Slow path: Full table scan with optional filtering */
    rc = btree_cursor_first(table_tree, &cursor);
    if (rc != 0) {
        /* Empty table or error */
        printf("\n0 row(s) selected.\n");
        btree_close(table_tree);
        return 0;
    }

    /* Iterate through all rows */
    while (cursor.valid) {
        row_page = cursor.value;

        /* Fetch row data */
        rc = cache_get_page(exec->cache, row_page, &page_data);
        if (rc != 0) {
            cache_unpin(exec->cache, row_page);
            btree_cursor_next(&cursor);
            continue;
        }

        /* Deserialize row */
        row_init(&row);
        rc = row_deserialize(&row, page_data, 4096);
        cache_unpin(exec->cache, row_page);

        if (rc < 0) {
            row_clear(&row);
            btree_cursor_next(&cursor);
            continue;
        }

        /* Apply WHERE filter if present */
        if (select_stmt->where.has_condition) {
            int passes_filter = 0;

            /* Find column index */
            int col_idx = -1;
            for (i = 0; i < schema.column_count; i++) {
                if (strcmp(select_stmt->where.column_name, schema.columns[i].name) == 0) {
                    col_idx = i;
                    break;
                }
            }

            if (col_idx < 0 || col_idx >= row.column_count) {
                row_clear(&row);
                btree_cursor_next(&cursor);
                continue;
            }

            const struct amidb_value *col_val = row_get_value(&row, col_idx);

            /* Compare values based on type and operator */
            if (col_val->type == AMIDB_TYPE_INTEGER &&
                select_stmt->where.value.type == SQL_VALUE_INTEGER) {
                int32_t row_val = col_val->u.i;
                int32_t where_val = select_stmt->where.value.int_value;

                switch (select_stmt->where.op) {
                    case SQL_OP_EQ: passes_filter = (row_val == where_val); break;
                    case SQL_OP_NE: passes_filter = (row_val != where_val); break;
                    case SQL_OP_LT: passes_filter = (row_val < where_val); break;
                    case SQL_OP_LE: passes_filter = (row_val <= where_val); break;
                    case SQL_OP_GT: passes_filter = (row_val > where_val); break;
                    case SQL_OP_GE: passes_filter = (row_val >= where_val); break;
                }
            } else if (col_val->type == AMIDB_TYPE_TEXT &&
                      select_stmt->where.value.type == SQL_VALUE_TEXT) {
                char row_str[256];
                snprintf(row_str, sizeof(row_str), "%.*s",
                        (int)col_val->u.blob.size, (char*)col_val->u.blob.data);
                int cmp = strcmp(row_str, select_stmt->where.value.text_value);

                switch (select_stmt->where.op) {
                    case SQL_OP_EQ: passes_filter = (cmp == 0); break;
                    case SQL_OP_NE: passes_filter = (cmp != 0); break;
                    case SQL_OP_LT: passes_filter = (cmp < 0); break;
                    case SQL_OP_LE: passes_filter = (cmp <= 0); break;
                    case SQL_OP_GT: passes_filter = (cmp > 0); break;
                    case SQL_OP_GE: passes_filter = (cmp >= 0); break;
                }
            }

            if (!passes_filter) {
                row_clear(&row);
                btree_cursor_next(&cursor);
                continue;
            }
        }

        /* Print matching row */
        for (i = 0; i < schema.column_count && i < row.column_count; i++) {
            const struct amidb_value *val = row_get_value(&row, i);
            if (val->type == AMIDB_TYPE_INTEGER) {
                printf("%-20d", val->u.i);
            } else if (val->type == AMIDB_TYPE_TEXT) {
                printf("%-20.*s", (int)val->u.blob.size, (char*)val->u.blob.data);
            } else if (val->type == AMIDB_TYPE_NULL) {
                printf("%-20s", "NULL");
            }
        }
        printf("\n");
        match_count++;

        row_clear(&row);
        btree_cursor_next(&cursor);
    }

    printf("\n%d row(s) selected.\n", match_count);
    btree_close(table_tree);
    return 0;
}

/*
 * Execute UPDATE (Week 8: stub)
 */
int executor_update(struct sql_executor *exec, const struct sql_update *update_stmt) {
    set_error(exec, "UPDATE not yet implemented");
    return -1;
}

/*
 * Execute DELETE (Week 8: stub)
 */
int executor_delete(struct sql_executor *exec, const struct sql_delete *delete_stmt) {
    set_error(exec, "DELETE not yet implemented");
    return -1;
}

/* ========== Helper Functions ========== */

/*
 * Set executor error message
 */
static void set_error(struct sql_executor *exec, const char *message) {
    strncpy(exec->error_msg, message, sizeof(exec->error_msg) - 1);
    exec->error_msg[sizeof(exec->error_msg) - 1] = '\0';
    exec->has_error = 1;
}
